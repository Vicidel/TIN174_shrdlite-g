
import {WorldState, world_object_counter} from "./World";
import {Edge, Graph, SearchResult, aStarSearch} from "./Graph";
import {ShrdliteResult, DNFFormula, Literal} from "./Types";
import {current_relation, physical_laws} from "./Interpreter";
import {heuristics} from "./Heuristics";

/********************************************************************************
** Planner

The goal of the Planner module is to take the interpetation(s)
produced by the Interpreter module and to plan a sequence of 
actions for the robot to put the world into a state compatible 
with the user's command, i.e. to achieve what the user wanted.

You should implement the function 'makePlan'. 
The planner should use your A* search implementation to find a plan.
********************************************************************************/

//////////////////////////////////////////////////////////////////////
// exported functions, classes and interfaces/types

/* Top-level driver for the Planner. 
 * It calls `makePlan` for each given interpretation generated by the Interpreter. 
 * You don't have to change this function.
 *
 * @param interpretations: List of possible interpretations.
 * @param currentState: The current state of the world.
 * @returns: List of planner results, which are the interpretation results augmented with plans. 
 *           Each plan is represented by a list of strings.
 *           If there's planning error, it returns a string with a description of the error.
 */

export function plan(interpretations : ShrdliteResult[], currentState : WorldState) : string | ShrdliteResult[] {
    var errors : string[] = [];
    var plans : ShrdliteResult[] = [];
    interpretations.forEach((result) => {
        var theplan : string | string[] = makePlan(result.interpretation, currentState);
        if (typeof(theplan) === "string") {
            errors.push(theplan);
        } else {
            result.plan = theplan;
            if (result.plan.length == 0) {
                result.plan.push("That is already true!");
            }
            plans.push(result);
        }
    });
    if (plans.length) {
        return plans;
    } else {
        // merge all errors into one
        return errors.join(" ; ");
    }
}

/* The core planner function. 
 * The code here is just a template; you should rewrite this function entirely. 
 * In this template, the code produces a dummy plan which is not connected 
 * to the argument 'interpretation'. Your version of the function should
 * analyse 'interpretation' in order to figure out what plan to return.
 *
 * @param interpretation: The logical interpretation of the user's desired goal. 
 * @param state: The current world state.
 * @returns: A plan, represented by a list of strings.
 *           If there's a planning error, it returns a string with a description of the error.
 */

function makePlan(interpretation : DNFFormula, state : WorldState) : string | string[] {
    // Create search graph, implements
    //      interface Graph<Node>
    //          outgoingEdges(node : Node) : Edge<Node>[];
    //          compareNodes : CompareFunction<Node>

    var planningGraph : PlanningGraph = new PlanningGraph(state);

    // Build anonymized functions
    //      goal : (n:Node) => boolean
    //      heuristics : (n:Node) => number
    var goal = (node : number) =>
        goalTest(interpretation, planningGraph.state[node]);
    var heuristic = (node : number) =>
        heuristics(interpretation, planningGraph.state[node]);

    // Perform A* search
    var searchResult = aStarSearch(planningGraph, 0, goal, heuristic, 20);
    console.log("Nodes visited: " + searchResult.visited.toString());
    if (searchResult.timeout == true){
        return "search timed out";
    }
    var roughMoves = searchResult.path.map(
        i => planningGraph.action[i]
    );

    var holding = !!state.holding;
    var arm = [state.arm[0], state.arm[1]];
    var plan : string[] = [];

    for (var stack of roughMoves) {
        if (stack[0] < 0) continue;

        if (arm[0] < stack[0])
        {
        	var diff  : number = stack[0] - arm[0];
            if (diff==1)
                plan.push(`Moving forward one row.`);
            else
                plan.push(`Moving forward ${diff} rows.`);
        }
        while (arm[0] < stack[0]) {
            arm[0]++;
            plan.push('f');
        }

        if (arm[0] > stack[0])
        {
        	var diff  : number = -(stack[0] - arm[0]);
            if (diff==1)
                plan.push(`Moving backward one row.`);
            else
                plan.push(`Moving backward ${diff} rows.`);
        }
        while (arm[0] > stack[0]) {
            arm[0]--;
            plan.push('b');
        }

        if (arm[1] < stack[1])
        {
        	var diff  : number = stack[1] - arm[1];
            if (diff==1)
                plan.push(`Moving right one column.`);
            else
                plan.push(`Moving right ${diff} columns.`);
        }
        while (arm[1] < stack[1]) {
            arm[1]++;
            plan.push('r');
        }

        if (arm[1] > stack[1])
        {
        	var diff  : number = -(stack[1] - arm[1]);
            if (diff==1)
                plan.push(`Moving left one column.`);
            else
                plan.push(`Moving left ${diff} columns.`);
        }
        while (arm[1] > stack[1]) {
            arm[1]--;
            plan.push('l');
        }
        
        var object_name : string = state.objects[stack[2]].toStringAdv();
        var number_of_object : number = world_object_counter(state.objects[stack[2]], state);
        var identifier : string = (number_of_object == 1) ? 'the' : 'a';
        plan.push(holding ? `Dropping the ${object_name}` : `Picking up ${identifier} ${object_name}`)
        plan.push(holding ? 'd' : 'p');
        holding = !holding;
    }

    if (arm[0] != 0 || arm[1] != 0) 
    	plan.push('Going back to starting position.')
    while (arm[0] > 0) {
        arm[0]--;
        plan.push('b');
    }
    while (arm[1] > 0) {
        arm[1]--;
        plan.push('l');
    }
    // Translate result into moves
    return plan;
}

class PlanningGraph implements Graph<number> {

    action : [number, number, string][]; // Action taken to reach node
    state : WorldState[];               // WorldState represented by node

    constructor(initialState : WorldState) {
        
        this.action = [[-1,-1, '#0 ']];
        this.state = [initialState];

    }

    compareNodes(a : number, b : number) : number {
        return a - b;
    }

    outgoingEdges(node : number) : Edge<number>[] {
        var result : Edge<number>[] = [];
        var object_id : string;

        for (var row = 0; row < this.state[node].stacks.length; row++) {
            for (var col = 0; col < this.state[node].stacks[row].length; col++) {
                // Don't include "undo"
                if (row == this.action[node][0])
                    if (col == this.action[node][1])
                        continue;

                // Check for validity and generate next state
                var nextState : WorldState = this.tryMove(this.state[node], row, col);
                if (nextState == undefined)
                    continue;

                // for talking arm
                if (nextState.holding) {
                	object_id = nextState.holding;
                }
                else {
                	var height : number = nextState.stacks[row][col].length;
                	object_id = nextState.stacks[row][col][height-1];
                }

                // Add to result
                var edge : Edge<number> = new Edge<number>();
                edge.from = node;
                edge.to = this.action.length;
                edge.cost = 1;
                if (!nextState.holding) {
                    edge.cost += Math.abs(row - this.action[node][0]);
                    edge.cost += Math.abs(col - this.action[node][1]);
                }
                result.push(edge);

                // Add to graph
                this.action.push([row, col, object_id]);
                this.state.push(nextState);
            }
        }

        // Don't need to retain expanded states
        this.state[node] = null;

        return result;
    }

    tryMove(state : WorldState, row: number, col: number) : WorldState{
        // number of objects in affected stack
        var height = state.stacks[row][col].length;
        
        // deep (enough) copy
        var newStacks: string[][][] = [];
        var k = state.stacks.length;
        while (k--)
            newStacks[k] = state.stacks[k];

        k = state.stacks[row].length;
        newStacks[row] = [];
        while (k--)
            newStacks[row][k] = state.stacks[row][k];

        if (state.holding == null) {
            if (height > 0) {
                newStacks[row][col] = [];
                while (height--)
                    newStacks[row][col][height] = state.stacks[row][col][height];
                var holding: string = newStacks[row][col].pop();
                return {
                    "stacks": newStacks,
                    "holding": holding,
                    "arm": [0,0],
                    "objects": state.objects,
                    "examples": null
                };
            } else {
                // Nothing to pick up
                return null;
            }
        } else {
            if (height == 0) {
                newStacks[row][col] = [state.holding];
                return {
                    "stacks": newStacks,
                    "holding": null,
                    "arm": [0,0],
                    "objects": state.objects,
                    "examples": null
                };
            } else {
                var obj1 = state.objects[state.holding];
                var obj2 = state.objects[state.stacks[row][col][height-1]];
                if (physical_laws("ontop", obj1, obj2) || physical_laws("inside", obj1, obj2)) {
                    newStacks[row][col] = [];
                    while (height--)
                        newStacks[row][col][height] = state.stacks[row][col][height];
                    newStacks[row][col].push(state.holding);
                    return {
                        "stacks": newStacks,
                        "holding": null,
                        "arm": [0,0],
                        "objects": state.objects,
                        "examples": null
                    };
                } else {
                    return null;
                }
            }
        }
    }
}

function goalTest(interpretation : DNFFormula, state : WorldState) : boolean {
    // If any conjunction is true, return true
    var i = interpretation.conjuncts.length;

    while (i--) {
        var alltrue = interpretation.conjuncts[i].literals.every(
            (lit) => xor(!lit.polarity,
                current_relation(state, lit.relation, lit.args[0], lit.args[1]))
        );
        if (alltrue) return true;
    }
    return false;
}

function xor(a : boolean, b : boolean) : boolean {
    return a ? !b : b;
}
